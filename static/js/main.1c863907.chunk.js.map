{"version":3,"sources":["components/Header.js","components/three/Test/Test.js","components/three/Test2/Test2.js","components/three/Test3/Test3.js","components/three/Test4/Test4.js","components/three/Test5/Test5.js","components/three/Test6/Test6.js","components/three/resources/empty_warehouse_01_2k.hdr","components/three/Test7/Test7.js","components/three/Test7/vertex.glsl","components/three/Test7/fragment.glsl","pages/HomePage.js","pages/NFTPage.js","RouterManager.js","App.js","index.js"],"names":["Header","Container","Grid","container","item","md","xs","React","Component","clock","THREE","hdrEquirect","RGBELoader","load","emptyWharehouse","mapping","Test7","props","state","shouldStopAutoRotate","start","bind","stop","animate","onWindowResize","getControls1","getControls2","getCamera1","getCamera2","getScene1","getLight1","getSizes","getWater","getRenderer","getEffectComposer","this","mount","camera","aspect","clientWidth","clientHeight","updateProjectionMatrix","camera2","renderer","setSize","canvas","controls","OrbitControls","enableDamping","minPolarAngle","Math","PI","maxPolarAngle","minDistance","maxDistance","rotateSpeed","enablePan","autoRotate","controls2","sizes","width","height","position","set","scene","color","fog","background","window","addEventListener","light","uBigWavesElevation","waterGeometry","waterMaterial","vertexShader","fragmentShader","uniforms","value","uBigWavesFrequency","uTime","uBigWavesSpeed","uDepthColor","uSurfaceColor","uColorOffset","uColorMultiplier","uSmallWavesElevation","uSmallWavesFrequency","uSmallWavesSpeed","uSmallIterations","fogColor","type","fogNear","near","fogFar","far","water","rotation","x","scale","y","antialias","alpha","setClearColor","setPixelRatio","min","devicePixelRatio","scene2","renderTarget2","minFilter","magFilter","format","effectComposer","EffectComposer","renderPass","RenderPass","addPass","phib","xc","yc","uc","vc","r","s","hi","h","w2","w","ul","ur","vl","vh","positions","uvs","phia","i","push","cos","sin","geometry","setAttribute","Float32Array","renderTarget","material","map","texture","getRounderdCornersGeometry","mesh","side","receiveShadow","transmission","thickness","roughness","envMapIntensity","envMap","shape","eps","radius","absarc","amount","bevelEnabled","bevelSegments","smoothness","steps","bevelSize","bevelThickness","curveSegments","center","domElement","water2","water3","add","plane","getPlaneRoundedCorners","planeTransparent","getPlaneRoundedCornersTransparent","hasRandomInitialPosition","randomX","ceil","random","round","randomY","appendChild","removeChild","frameId","requestAnimationFrame","cancelAnimationFrame","elapsedTime","getElapsedTime","update","shouldRotateAutomatically","renderScene","setRenderTarget","render","onMouseDown","setState","style","ref","HomePage","maxWidth","RouterManager","exact","path","element","NFTPage","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1c863907.chunk.js","sourcesContent":["import React from \"react\";\r\nimport Container from '@material-ui/core/Container';\r\nimport Grid from '@material-ui/core/Grid';\r\n\r\n\r\nclass Header extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <Container  >\r\n            <Grid container >\r\n                <Grid item md={2} xs={6}>\r\n                    <div>\r\n                        <h1 >\r\n                        Header\r\n                        </h1>\r\n                    </div>\r\n                </Grid>\r\n                <Grid item md={9} xs={false}>\r\n                   \r\n                </Grid>\r\n                <Grid item md={1} xs={6}>\r\n                    <div>\r\n                        <h1 >\r\n                        Wallet\r\n                        </h1>\r\n                    </div>\r\n                </Grid>\r\n            </Grid>\r\n        </Container>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Header;","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n   \r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n }\r\n  \r\n  componentDidMount() {\r\n    const debugObject = {}\r\n    debugObject.depthColor = '#517acd'\r\n    debugObject.surfaceColor = '#c9cfe8'\r\n\r\n    const width = this.mount.clientWidth\r\n    const height = this.mount.clientHeight\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n\r\n    const scene = new THREE.Scene()\r\n    const camera = new THREE.PerspectiveCamera(\r\n      75,\r\n      width / height,\r\n      0.1,\r\n      1000\r\n    )\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true })\r\n    \r\n    // console.log(\"@@@ renderer\",renderer)\r\n    const near = 0.1;\r\n    const far = 4;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far);\r\n    scene.background = new THREE.Color(color);\r\n    const color2 = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color2, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    scene.add(light);\r\n\r\n\r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader:waterVertexShader\r\n        ,\r\n        fragmentShader:waterFragmentShader\r\n        ,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value: 0.291},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(3.914,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color(debugObject.depthColor) },\r\n            uSurfaceColor: { value: new THREE.Color(debugObject.surfaceColor) },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n          fogNear:     { type: \"f\", value: scene.fog.near },\r\n          fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n    \r\n    scene.add(water)\r\n\r\n    renderer.setClearColor('#000000')\r\n    renderer.setSize(width, height)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.renderer = renderer\r\n    this.material = waterMaterial\r\n    this.water = water\r\n\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n\r\n    const controls = new OrbitControls(camera, renderer.domElement)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.7\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 3;\r\n    controls.rotateSpeed =0.3\r\n\r\n    // controls2.rotateSpeed *= -1;\r\n    controls.autoRotate = true;\r\n    this.controls = controls\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    this.material.needsUpdate = true\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n\r\n    this.water.updateMatrix()\r\n    this.controls.update()\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.renderer.render(this.scene, this.camera)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test;","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\n\r\nimport { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js'\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\r\n\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test2 extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n   \r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n }\r\n  \r\n  componentDidMount() {\r\n    const debugObject = {}\r\n    debugObject.depthColor = '#517acd'\r\n    debugObject.surfaceColor = '#c9cfe8'\r\n\r\n    const width = this.mount.clientWidth\r\n    const height = this.mount.clientHeight\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n\r\n    const scene = new THREE.Scene()\r\n    const camera = new THREE.PerspectiveCamera(\r\n      75,\r\n      width / height,\r\n      0.1,\r\n      1000\r\n    )\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true })\r\n    \r\n    // console.log(\"@@@ renderer\",renderer)\r\n    const near = 0.1;\r\n    const far = 4;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far);\r\n    scene.background = new THREE.Color(color);\r\n    const color2 = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color2, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    scene.add(light);\r\n\r\n    \r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader:waterVertexShader\r\n        ,\r\n        fragmentShader:waterFragmentShader\r\n        ,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value: 0.291},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(3.914,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color(debugObject.depthColor) },\r\n            uSurfaceColor: { value: new THREE.Color(debugObject.surfaceColor) },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n          fogNear:     { type: \"f\", value: scene.fog.near },\r\n          fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n    \r\n    scene.add(water)\r\n\r\n    renderer.setClearColor('#000000')\r\n    renderer.setSize(width, height)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.renderer = renderer\r\n    this.material = waterMaterial\r\n    this.water = water\r\n\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n\r\n    const controls = new OrbitControls(camera, renderer.domElement)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.7\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 3;\r\n    controls.rotateSpeed =0.3\r\n\r\n    // controls2.rotateSpeed *= -1;\r\n    controls.autoRotate = true;\r\n\r\n    const renderTarget = new THREE.WebGLRenderTarget(\r\n        800,\r\n        600,\r\n        {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBAFormat\r\n        }\r\n    )\r\n\r\n    const effectComposer = new EffectComposer(renderer, renderTarget)\r\n    effectComposer.setSize(width, height)\r\n    effectComposer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    const renderPass = new RenderPass(scene, camera)\r\n    effectComposer.addPass(renderPass)\r\n    const glitchPass = new GlitchPass()\r\n    effectComposer.addPass(glitchPass)\r\n\r\n    this.effectComposer = effectComposer\r\n    this.controls = controls\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    this.material.needsUpdate = true\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n\r\n    this.water.updateMatrix()\r\n    this.controls.update()\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.effectComposer.render()\r\n\r\n    // this.renderer.render(this.scene, this.camera)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test2;","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test3 extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n   \r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n }\r\n  \r\n  componentDidMount() {\r\n    const debugObject = {}\r\n    debugObject.depthColor = '#517acd'\r\n    debugObject.surfaceColor = '#c9cfe8'\r\n\r\n\r\n    // Canvas\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true })\r\n\r\n    const canvas = renderer.domElement\r\n\r\n    // Scene\r\n    const scene = new THREE.Scene()\r\n    const near = 0.1;\r\n    const far = 4;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far);\r\n    scene.background = new THREE.Color(color);\r\n    const color2 = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color2, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    scene.add(light);\r\n    /**\r\n     * Water\r\n     */\r\n    // Geometry\r\n    // const waterGeometry = new THREE.PlaneGeometry(2, 2, 128, 128)\r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader: waterVertexShader,\r\n        fragmentShader: waterFragmentShader,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value: 0.291},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(1.826,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color(debugObject.depthColor) },\r\n            uSurfaceColor: { value: new THREE.Color(debugObject.surfaceColor) },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n          fogNear:     { type: \"f\", value: scene.fog.near },\r\n          fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    // Mesh\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n\r\n    scene.add(water)\r\n\r\n    /**\r\n     * Sizes\r\n     */\r\n  \r\n    const sizes = {\r\n        width: this.mount.clientWidth,\r\n        height: this.mount.clientHeight\r\n    }\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n\r\n    /**\r\n     * Camera\r\n     */\r\n    // Base camera\r\n    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera.position.set(1, 0.01, 1)\r\n\r\n    scene.add(camera)\r\n    ////////////////////\r\n    const camera2 = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera2.position.set(0, 0, 1)\r\n\r\n    var renderTarget = new THREE.WebGLRenderTarget(512, 512);\r\n\r\n    const scene2 = new THREE.Scene()\r\n\r\n    // scene2.fog = new THREE.Fog(color, near, far);\r\n    // scene2.background = new THREE.Color(color);\r\n\r\n    scene2.fog = new THREE.Fog(color, near, far);\r\n    scene2.add(light);\r\n    const planeGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n\r\n    // const planeGeometry =new THREE.SphereGeometry( 15, 32, 16 );\r\n    // Material\r\n    const planeMaterial = new THREE.MeshBasicMaterial({\r\n        map: renderTarget.texture\r\n    })\r\n\r\n    const plane = new THREE.Mesh(planeGeometry, planeMaterial)\r\n    // plane.rotation.y = 0.8\r\n    plane.material.side = THREE.DoubleSide;\r\n\r\n    plane.scale.x = 0.4\r\n    plane.scale.y = 0.6\r\n    scene2.add(plane);\r\n    const controls2 = new OrbitControls(camera2, canvas)\r\n    controls2.enableDamping = true\r\n    controls2.rotateSpeed =0.8\r\n\r\n\r\n    // Controls\r\n    const controls = new OrbitControls(camera, canvas)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.5\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 2;\r\n    controls.rotateSpeed =0.5\r\n\r\n    // controls2.rotateSpeed *= -1;\r\n    controls.autoRotate = true;\r\n    /**\r\n     * Renderer\r\n     */\r\n    \r\n    renderer.setSize(sizes.width, sizes.height)\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n\r\n\r\n\r\n    // const renderTarget2 = new THREE.WebGLRenderTarget(\r\n    //     800,\r\n    //     600,\r\n    //     {\r\n    //         minFilter: THREE.LinearFilter,\r\n    //         magFilter: THREE.LinearFilter,\r\n    //         format: THREE.RGBAFormat\r\n    //     }\r\n    // )\r\n    // const effectComposer = new EffectComposer(renderer,renderTarget2)\r\n    // effectComposer.setSize(sizes.width, sizes.height)\r\n    // effectComposer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    // const renderPass = new RenderPass(scene2, camera2)\r\n    // effectComposer.addPass(renderPass)\r\n    \r\n    // const glitchPass = new GlitchPass()\r\n    // effectComposer.addPass(glitchPass)\r\n\r\n    // const rgbShiftPass = new ShaderPass(RGBShiftShader)\r\n    // effectComposer.addPass(rgbShiftPass)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.scene2 = scene2\r\n    this.camera2 = camera2\r\n    this.renderer = renderer\r\n    this.material = waterMaterial\r\n    this.water = water\r\n    this.controls = controls\r\n    this.renderTarget = renderTarget\r\n\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    this.material.needsUpdate = true\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n\r\n    this.water.updateMatrix()\r\n    this.controls.update()\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.renderer.setRenderTarget( this.renderTarget );\r\n\r\n    this.renderer.render(this.scene, this.camera, this.renderTarget);\r\n    this.renderer.setRenderTarget( null );\r\n\r\n    //////////\r\n\r\n    // Render\r\n    this.renderer.render(this.scene2, this.camera2)\r\n    // this.renderer.render(this.scene, this.camera)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test3;","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\r\nimport { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js'\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test4 extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n   \r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n }\r\n  \r\n  componentDidMount() {\r\n    const debugObject = {}\r\n    debugObject.depthColor = '#517acd'\r\n    debugObject.surfaceColor = '#c9cfe8'\r\n\r\n\r\n    // Canvas\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true,logarithmicDepthBuffer:true  })\r\n\r\n    const canvas = renderer.domElement\r\n\r\n    // Scene\r\n    const scene = new THREE.Scene()\r\n    const near = 0.1;\r\n    const far = 4;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far);\r\n    scene.background = new THREE.Color(color);\r\n    const color2 = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color2, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    scene.add(light);\r\n    /**\r\n     * Water\r\n     */\r\n    // Geometry\r\n    // const waterGeometry = new THREE.PlaneGeometry(2, 2, 128, 128)\r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader: waterVertexShader,\r\n        fragmentShader: waterFragmentShader,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value: 0.291},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(1.826,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color(debugObject.depthColor) },\r\n            uSurfaceColor: { value: new THREE.Color(debugObject.surfaceColor) },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n          fogNear:     { type: \"f\", value: scene.fog.near },\r\n          fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    // Mesh\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n\r\n    scene.add(water)\r\n\r\n    /**\r\n     * Sizes\r\n     */\r\n  \r\n    const sizes = {\r\n        width: this.mount.clientWidth,\r\n        height: this.mount.clientHeight\r\n    }\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n\r\n    /**\r\n     * Camera\r\n     */\r\n    // Base camera\r\n    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera.position.set(1, 0.01, 1)\r\n\r\n    scene.add(camera)\r\n    ////////////////////\r\n    const camera2 = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera2.position.set(0, 0, 1.5)\r\n\r\n    var renderTarget = new THREE.WebGLRenderTarget(512, 512);\r\n\r\n    const scene2 = new THREE.Scene()\r\n\r\n    // scene2.fog = new THREE.Fog(color, near, far);\r\n    // scene2.background = new THREE.Color(color);\r\n\r\n    scene2.fog = new THREE.Fog(color, near, far);\r\n    scene2.add(light);\r\n    const planeGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n\r\n    // const planeGeometry =new THREE.SphereGeometry( 15, 32, 16 );\r\n    // Material\r\n    const planeMaterial = new THREE.MeshBasicMaterial({\r\n        map: renderTarget.texture\r\n    })\r\n\r\n    const plane = new THREE.Mesh(planeGeometry, planeMaterial)\r\n    // plane.rotation.y = 0.8\r\n    plane.material.side = THREE.DoubleSide;\r\n    plane.receiveShadow = false;\r\n\r\n    plane.scale.x = 0.4\r\n    plane.scale.y = 0.6\r\n    scene2.add(plane);\r\n    const controls2 = new OrbitControls(camera2, canvas)\r\n    controls2.enableDamping = true\r\n    controls2.rotateSpeed =0.8\r\n    controls2.minDistance = 1.5;\r\n\r\n    // Controls\r\n    const controls = new OrbitControls(camera, canvas)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.5\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 2;\r\n    controls.rotateSpeed =0.5\r\n\r\n    // controls2.rotateSpeed *= -1;\r\n    controls.autoRotate = true;\r\n    /**\r\n     * Renderer\r\n     */\r\n    \r\n    renderer.setSize(sizes.width, sizes.height)\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n\r\n    const renderTarget2 = new THREE.WebGLRenderTarget(\r\n        800,\r\n        600,\r\n        {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBAFormat\r\n        }\r\n    )\r\n    const effectComposer = new EffectComposer(renderer,renderTarget2)\r\n    effectComposer.setSize(sizes.width, sizes.height)\r\n    effectComposer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    const renderPass = new RenderPass(scene2, camera2)\r\n    effectComposer.addPass(renderPass)\r\n    \r\n    const glitchPass = new GlitchPass()\r\n    effectComposer.addPass(glitchPass)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.scene2 = scene2\r\n    this.camera2 = camera2\r\n    this.renderer = renderer\r\n    this.material = waterMaterial\r\n    this.water = water\r\n    this.controls = controls\r\n    this.renderTarget = renderTarget\r\n    this.effectComposer = effectComposer\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    this.material.needsUpdate = true\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n\r\n    this.water.updateMatrix()\r\n    this.controls.update()\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.renderer.setRenderTarget( this.renderTarget );\r\n\r\n    this.renderer.render(this.scene, this.camera, this.renderTarget);\r\n    this.renderer.setRenderTarget( null );\r\n\r\n    //////////\r\n\r\n    // Render\r\n    this.effectComposer.render()\r\n    // this.renderer.render(this.scene2, this.camera2)\r\n    // this.renderer.render(this.scene, this.camera)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test4;","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\r\n// import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js'\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test5 extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n    this.getControls1 = this.getControls1.bind(this)\r\n    this.getControls2 = this.getControls2.bind(this)\r\n    this.getCamera1 = this.getCamera1.bind(this)\r\n    this.getCamera2 = this.getCamera2.bind(this)\r\n\r\n    this.getScene1 = this.getScene1.bind(this)\r\n    this.getPlane = this.getPlane.bind(this)\r\n\r\n    this.getLight1 = this.getLight1.bind(this)\r\n\r\n    this.getSizes = this.getSizes.bind(this)\r\n    this.getWater = this.getWater.bind(this)\r\n\r\n    this.getRenderer = this.getRenderer.bind(this)\r\n    this.getEffectComposer = this.getEffectComposer.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n   \r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n  }\r\n\r\n  getControls1(camera, canvas){\r\n    const controls = new OrbitControls(camera, canvas)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.5\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 2;\r\n    controls.rotateSpeed =0.5\r\n\r\n    controls.autoRotate = true\r\n    return controls\r\n  }\r\n\r\n  getControls2(camera2, canvas){\r\n    const controls2 = new OrbitControls(camera2, canvas)\r\n    controls2.enableDamping = true\r\n    // controls2.rotateSpeed =0.8\r\n    controls2.minDistance = 1.5;\r\n    return controls2\r\n  }\r\n\r\n  getCamera1(sizes){\r\n    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera.position.set(1, 0.01, 1)\r\n    return camera\r\n  }\r\n\r\n  getCamera2(sizes){\r\n    const camera2 = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera2.position.set(0, 0, 1.5)\r\n    return camera2\r\n  }\r\n\r\n  getScene1(){\r\n    const scene = new THREE.Scene()\r\n    const near = 0.1;\r\n    const far = 5;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far)\r\n    scene.background = new THREE.Color(color)\r\n    return scene\r\n  }\r\n\r\n  getPlane(renderTarget){\r\n    const planeGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n\r\n    // Material\r\n    const planeMaterial = new THREE.MeshBasicMaterial({\r\n        map: renderTarget.texture\r\n    })\r\n\r\n    const plane = new THREE.Mesh(planeGeometry, planeMaterial)\r\n    plane.material.side = THREE.DoubleSide\r\n    plane.receiveShadow = false\r\n\r\n    plane.scale.x = 0.4\r\n    plane.scale.y = 0.6\r\n    return plane\r\n  }\r\n\r\n  getSizes(){\r\n    const sizes = {\r\n      width: this.mount.clientWidth,\r\n      height: this.mount.clientHeight\r\n    }\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n    return sizes\r\n  }\r\n\r\n  getLight1(){\r\n    const color = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    return light\r\n  }\r\n\r\n  getWater(scene,uBigWavesElevation){\r\n   /**\r\n     * Water\r\n     */\r\n    // Geometry\r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader: waterVertexShader,\r\n        fragmentShader: waterFragmentShader,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value:  uBigWavesElevation},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(1.826,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color('#517acd') },\r\n            uSurfaceColor: { value: new THREE.Color('#c9cfe8') },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n            fogNear:     { type: \"f\", value: scene.fog.near },\r\n            fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    // Mesh\r\n\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n    return water\r\n  }\r\n\r\n  getRenderer(sizes){\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true,logarithmicDepthBuffer:true  })\r\n    renderer.setSize(sizes.width, sizes.height)\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    return renderer\r\n  }\r\n\r\n  getEffectComposer(renderer,sizes,scene2,camera2){\r\n    const renderTarget2 = new THREE.WebGLRenderTarget(\r\n      800,\r\n      600,\r\n      {\r\n          minFilter: THREE.LinearFilter,\r\n          magFilter: THREE.LinearFilter,\r\n          format: THREE.RGBAFormat\r\n      }\r\n    )\r\n    const effectComposer = new EffectComposer(renderer,renderTarget2)\r\n    effectComposer.setSize(sizes.width, sizes.height)\r\n    effectComposer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    const renderPass = new RenderPass(scene2, camera2)\r\n    effectComposer.addPass(renderPass)\r\n    return effectComposer\r\n  }  \r\n  componentDidMount() {\r\n    const sizes = this.getSizes()\r\n    // Canvas\r\n    // Scene 1\r\n    const renderer = this.getRenderer(sizes)\r\n    const canvas = renderer.domElement\r\n    const scene = this.getScene1()\r\n    const light = this.getLight1()\r\n    const water = this.getWater(scene,0.191)\r\n    const water2 = this.getWater(scene,0.291)\r\n    const water3 = this.getWater(scene,0.391)\r\n\r\n    const camera = this.getCamera1(sizes)\r\n    const controls = this.getControls1(camera,canvas)\r\n\r\n    scene.add(water)\r\n    scene.add(water2)\r\n    scene.add(water3)\r\n\r\n    scene.add(light)\r\n    scene.add(camera)\r\n\r\n    // Scene 2 (main scene)\r\n    const scene2 = new THREE.Scene()\r\n    const camera2 = this.getCamera2(sizes)\r\n    const effectComposer = this.getEffectComposer(renderer,sizes,scene2,camera2)\r\n    const controls2 = this.getControls2(camera2,canvas)\r\n    const renderTarget = new THREE.WebGLRenderTarget(512, 512);\r\n    const plane = this.getPlane(renderTarget)\r\n\r\n    scene2.add(light)\r\n    scene2.add(plane);\r\n\r\n    // post processing\r\n    // const glitchPass = new GlitchPass()\r\n    // effectComposer.addPass(glitchPass)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.renderer = renderer\r\n    this.water = water\r\n    this.water2 = water2\r\n    this.water3 = water3\r\n\r\n    this.controls = controls\r\n    this.controls2 = controls2\r\n    this.renderTarget = renderTarget\r\n    this.effectComposer = effectComposer\r\n\r\n    // mandatory stuff\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n    this.water2.material.uniforms.uTime.value =elapsedTime*1.3\r\n    this.water3.material.uniforms.uTime.value =elapsedTime\r\n\r\n    this.controls.update()\r\n    this.controls2.update()\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.renderer.setRenderTarget( this.renderTarget );\r\n\r\n    this.renderer.render(this.scene, this.camera, this.renderTarget);\r\n    this.renderer.setRenderTarget( null );\r\n\r\n    // Render\r\n    this.effectComposer.render()\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test5;","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\r\n// import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js'\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test6 extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n    this.getControls1 = this.getControls1.bind(this)\r\n    this.getControls2 = this.getControls2.bind(this)\r\n    this.getCamera1 = this.getCamera1.bind(this)\r\n    this.getCamera2 = this.getCamera2.bind(this)\r\n\r\n    this.getScene1 = this.getScene1.bind(this)\r\n\r\n    this.getLight1 = this.getLight1.bind(this)\r\n\r\n    this.getSizes = this.getSizes.bind(this)\r\n    this.getWater = this.getWater.bind(this)\r\n\r\n    this.getRenderer = this.getRenderer.bind(this)\r\n    this.getEffectComposer = this.getEffectComposer.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n      this.camera2.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera2.updateProjectionMatrix()\r\n\r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n  }\r\n\r\n  getControls1(camera, canvas){\r\n    const controls = new OrbitControls(camera, canvas)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.5\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 2;\r\n    controls.rotateSpeed =1\r\n    controls.enablePan = false\r\n    controls.autoRotate = true\r\n    return controls\r\n  }\r\n\r\n  getControls2(camera2, canvas){\r\n    const controls2 = new OrbitControls(camera2, canvas)\r\n    controls2.enableDamping = true\r\n    // controls2.rotateSpeed =0.8\r\n    controls2.minDistance = 15\r\n    controls2.enablePan = false\r\n    return controls2\r\n  }\r\n\r\n  getCamera1(sizes){\r\n    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera.position.set(1, 0.01, 1)\r\n    return camera\r\n  }\r\n\r\n  getCamera2(sizes){\r\n    const camera2 = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera2.position.set(0, 0, 15)\r\n    return camera2\r\n  }\r\n\r\n  getScene1(){\r\n    const scene = new THREE.Scene()\r\n    const near = 0.1;\r\n    const far = 5;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far)\r\n    scene.background = new THREE.Color(color)\r\n    return scene\r\n  }\r\n\r\n  getSizes(){\r\n    const sizes = {\r\n      width: this.mount.clientWidth,\r\n      height: this.mount.clientHeight\r\n    }\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n    return sizes\r\n  }\r\n\r\n  getLight1(){\r\n    const color = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    return light\r\n  }\r\n\r\n  getWater(scene,uBigWavesElevation){\r\n   /**\r\n     * Water\r\n     */\r\n    // Geometry\r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader: waterVertexShader,\r\n        fragmentShader: waterFragmentShader,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value:  uBigWavesElevation},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(1.826,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color('#517acd') },\r\n            uSurfaceColor: { value: new THREE.Color('#c9cfe8') },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n            fogNear:     { type: \"f\", value: scene.fog.near },\r\n            fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    // Mesh\r\n\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n    return water\r\n  }\r\n\r\n  getRenderer(sizes){\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true,alpha: true })\r\n    renderer.setClearColor( 0x000000, 0 );\r\n    renderer.setSize(sizes.width, sizes.height)\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    return renderer\r\n  }\r\n\r\n  getEffectComposer(renderer,sizes,scene2,camera2){\r\n    const renderTarget2 = new THREE.WebGLRenderTarget(\r\n      800,\r\n      600,\r\n      {\r\n          minFilter: THREE.LinearFilter,\r\n          magFilter: THREE.LinearFilter,\r\n          format: THREE.RGBAFormat\r\n      }\r\n    )\r\n    const effectComposer = new EffectComposer(renderer,renderTarget2)\r\n    effectComposer.setSize(sizes.width, sizes.height)\r\n    effectComposer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    const renderPass = new RenderPass(scene2, camera2)\r\n    effectComposer.addPass(renderPass)\r\n    return effectComposer\r\n  }  \r\n\r\n  getPlaneRoundedCorners(renderTarget){\r\n    const material = new THREE.MeshBasicMaterial({\r\n        map: renderTarget.texture\r\n    })\r\n\r\n    const w = 9;\t// width\r\n    const h =  16;\t// height\r\n    const r = 0.5;\t// radius corner\r\n    const s = 18;\t// smoothness\r\n\r\n    // helper const's\r\n    const wi = w / 2 - r;\r\n    const hi = h / 2 - r;\r\n    const w2 = w / 2;\r\n    const h2 = h / 2;\r\n    const ul = r / w;\r\n    const ur = ( w - r ) / w;\r\n    const vl = r / h;\r\n    const vh = ( h - r ) / h;\r\n\r\n    let positions = [\r\n\r\n      -wi, -h2, 0,  wi, -h2, 0,  wi, h2, 0,\r\n      -wi, -h2, 0,  wi,  h2, 0, -wi, h2, 0,\t\r\n      -w2, -hi, 0, -wi, -hi, 0, -wi, hi, 0,\r\n      -w2, -hi, 0, -wi,  hi, 0, -w2, hi, 0,\t\r\n      wi, -hi, 0,  w2, -hi, 0,  w2, hi, 0,\r\n      wi, -hi, 0,  w2,  hi, 0,  wi, hi, 0\r\n      \r\n    ];\r\n\r\n    let uvs = [\r\n      \r\n      ul,  0, ur,  0, ur,  1,\r\n      ul,  0, ur,  1, ul,  1,\r\n      0, vl, ul, vl, ul, vh,\r\n      0, vl, ul, vh,  0, vh,\r\n      ur, vl,  1, vl,  1, vh,\r\n      ur, vl,  1, vh,\tur, vh \r\n      \r\n    ];\r\n\r\n    let phia = 0; \r\n    let phib, xc, yc, uc, vc;\r\n\r\n    for ( let i = 0; i < s * 4; i ++ ) {\r\n\r\n      phib = Math.PI * 2 * ( i + 1 ) / ( 4 * s );\r\n      \r\n      \r\n      xc = i < s || i >= 3 * s ? wi : - wi;\r\n      yc = i < 2 * s ? hi : -hi;\r\n\r\n      positions.push( xc, yc, 0, xc + r * Math.cos( phia ), yc + r * Math.sin( phia ), 0,  xc + r * Math.cos( phib ), yc + r * Math.sin( phib ), 0 );\r\n      \r\n      uc = xc = i < s || i >= 3 * s ? ur : ul;\r\n      vc = i < 2 * s ? vh : vl;\r\n      \r\n      uvs.push( uc, vc, uc + ul * Math.cos( phia ), vc + vl * Math.sin( phia ), uc + ul * Math.cos( phib ), vc + vl * Math.sin( phib ) );\r\n      \r\n      phia = phib;\r\n        \r\n    }\r\n    const geometry = new THREE.BufferGeometry( );\r\n    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions ), 3 ) );\r\n    geometry.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( uvs ), 2 ) );\r\n\r\n    const mesh  = new THREE.Mesh(geometry, material)\r\n    mesh.material.side = THREE.DoubleSide\r\n    mesh.receiveShadow = false\r\n    \r\n    // mesh.rotation.x = -Math.PI / 2\r\n    return mesh\r\n  }\r\n\r\n  componentDidMount() {\r\n    const sizes = this.getSizes()\r\n    // Canvas\r\n    // Scene 1\r\n    const renderer = this.getRenderer(sizes)\r\n    const canvas = renderer.domElement\r\n    const scene = this.getScene1()\r\n    const light = this.getLight1()\r\n    const water = this.getWater(scene,0.191)\r\n    const water2 = this.getWater(scene,0.291)\r\n    const water3 = this.getWater(scene,0.391)\r\n\r\n    const camera = this.getCamera1(sizes)\r\n    const controls = this.getControls1(camera,canvas)\r\n\r\n    scene.add(water)\r\n    scene.add(water2)\r\n    scene.add(water3)\r\n\r\n    scene.add(light)\r\n    scene.add(camera)\r\n\r\n    // Scene 2 (main scene)\r\n    const scene2 = new THREE.Scene()\r\n\r\n    const camera2 = this.getCamera2(sizes)\r\n    const effectComposer = this.getEffectComposer(renderer,sizes,scene2,camera2)\r\n    const controls2 = this.getControls2(camera2,canvas)\r\n    const renderTarget = new THREE.WebGLRenderTarget(512, 512);\r\n    const plane2 = this.getPlaneRoundedCorners(renderTarget)\r\n\r\n    scene2.add(light)\r\n    scene2.add(plane2);\r\n\r\n\r\n    // post processing\r\n    // const glitchPass = new GlitchPass()\r\n    // effectComposer.addPass(glitchPass)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.camera2 = camera2\r\n    this.renderer = renderer\r\n    this.water = water\r\n    this.water2 = water2\r\n    this.water3 = water3\r\n\r\n    this.controls = controls\r\n    this.controls2 = controls2\r\n    this.renderTarget = renderTarget\r\n    this.effectComposer = effectComposer\r\n\r\n    // mandatory stuff\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n    this.water2.material.uniforms.uTime.value =elapsedTime*1.3\r\n    this.water3.material.uniforms.uTime.value =elapsedTime\r\n\r\n    this.controls.update()\r\n    this.controls2.update()\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.renderer.setRenderTarget( this.renderTarget );\r\n    this.renderer.render(this.scene, this.camera, this.renderTarget);\r\n    this.renderer.setRenderTarget( null );\r\n    this.renderer.setClearColor( 0x000000, 0 );\r\n\r\n    // Render\r\n    this.effectComposer.render()\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test6;","export default __webpack_public_path__ + \"static/media/empty_warehouse_01_2k.37cf0892.hdr\";","import React from \"react\";\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\nimport * as THREE from 'three'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\r\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader\";\r\n\r\n// import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js'\r\n// import { DotScreenPass } from 'three/examples/jsm/postprocessing/DotScreenPass.js'\r\n// import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js'\r\n// import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js'\r\n// import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader.js'\r\n// import { GammaCorrectionShader } from 'three/examples/jsm/shaders/GammaCorrectionShader.js'\r\n// import { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js'\r\n// import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js'\r\n\r\n\r\nimport waterVertexShader from './vertex.glsl'\r\nimport waterFragmentShader from './fragment.glsl'\r\n\r\nimport emptyWharehouse from '../resources/empty_warehouse_01_2k.hdr'\r\nconst hdrEquirect = new RGBELoader().load(\r\n  emptyWharehouse,\r\n  () => {\r\n    hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;\r\n  }\r\n);\r\n\r\nconst clock = new THREE.Clock()\r\n\r\nclass Test7 extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n    this.state={\r\n      shouldStopAutoRotate:false\r\n    }\r\n\r\n    this.start = this.start.bind(this)\r\n    this.stop = this.stop.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.onWindowResize = this.onWindowResize.bind(this)\r\n    this.getControls1 = this.getControls1.bind(this)\r\n    this.getControls2 = this.getControls2.bind(this)\r\n    this.getCamera1 = this.getCamera1.bind(this)\r\n    this.getCamera2 = this.getCamera2.bind(this)\r\n\r\n    this.getScene1 = this.getScene1.bind(this)\r\n\r\n    this.getLight1 = this.getLight1.bind(this)\r\n\r\n    this.getSizes = this.getSizes.bind(this)\r\n    this.getWater = this.getWater.bind(this)\r\n\r\n    this.getRenderer = this.getRenderer.bind(this)\r\n    this.getEffectComposer = this.getEffectComposer.bind(this)\r\n  }\r\n\r\n  onWindowResize() {\r\n    if(this.mount != null){\r\n      this.camera.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n      this.camera2.aspect =this.mount.clientWidth / this.mount.clientHeight\r\n      this.camera2.updateProjectionMatrix()\r\n\r\n      this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight)\r\n    }\r\n  }\r\n\r\n  getControls1(camera, canvas){\r\n    const controls = new OrbitControls(camera, canvas)\r\n    controls.enableDamping = true\r\n    controls.minPolarAngle=Math.PI / 5\r\n    controls.maxPolarAngle=Math.PI / 2.5\r\n    controls.minDistance = 1;\r\n    controls.maxDistance = 2;\r\n    controls.rotateSpeed =1\r\n    controls.enablePan = false\r\n    controls.autoRotate = true\r\n    return controls\r\n  }\r\n\r\n  getControls2(camera2, canvas){\r\n    const controls2 = new OrbitControls(camera2, canvas)\r\n    controls2.enableDamping = true\r\n    // controls2.rotateSpeed =0.8\r\n    controls2.maxDistance = 19\r\n    controls2.minDistance = 15\r\n    controls2.minPolarAngle =1.19\r\n\t\tcontrols2.maxPolarAngle =  Math.PI * 0.6\r\n    controls2.enablePan = false\r\n    return controls2\r\n  }\r\n\r\n  getCamera1(sizes){\r\n    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera.position.set(1, 0.01, 1)\r\n    return camera\r\n  }\r\n\r\n  getCamera2(sizes){\r\n    const camera2 = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\r\n    camera2.position.set(0, 0, 15)\r\n    return camera2\r\n  }\r\n\r\n  getScene1(){\r\n    const scene = new THREE.Scene()\r\n    const near = 0.1;\r\n    const far = 5;\r\n    const color = '#FFFFFF';\r\n    scene.fog = new THREE.Fog(color, near, far)\r\n    scene.background = new THREE.Color(color)\r\n    return scene\r\n  }\r\n\r\n  getSizes(){\r\n    const sizes = {\r\n      width: this.mount.clientWidth,\r\n      height: this.mount.clientHeight\r\n    }\r\n    window.addEventListener('resize', this.onWindowResize, false);\r\n    return sizes\r\n  }\r\n\r\n  getLight1(){\r\n    const color = \"#FFFFFF\";\r\n    const intensity = 1;\r\n    const light = new THREE.DirectionalLight(color, intensity);\r\n    light.position.set(-1, 2, 4);\r\n    return light\r\n  }\r\n\r\n  getWater(scene,uBigWavesElevation){\r\n   /**\r\n     * Water\r\n     */\r\n    // Geometry\r\n    const waterGeometry = new THREE.PlaneGeometry(2, 2, 512, 512)\r\n    // Material\r\n    const waterMaterial = new THREE.ShaderMaterial({\r\n        vertexShader: waterVertexShader,\r\n        fragmentShader: waterFragmentShader,\r\n        uniforms:\r\n        {\r\n            uBigWavesElevation: { value:  uBigWavesElevation},\r\n            uBigWavesFrequency: { value: new THREE.Vector2(1.826,0.743) },\r\n            uTime: { value: 0 },\r\n            uBigWavesSpeed: { value: 0.75 },\r\n            uDepthColor: { value: new THREE.Color('#517acd') },\r\n            uSurfaceColor: { value: new THREE.Color('#c9cfe8') },\r\n            uColorOffset: { value: 0.028 },\r\n            uColorMultiplier: { value: 3.45 },\r\n            uSmallWavesElevation: { value: 0.105 },\r\n            uSmallWavesFrequency: { value: 3 },\r\n            uSmallWavesSpeed: { value: 0.1 },\r\n            uSmallIterations: { value: 4 },\r\n            fogColor:    { type: \"c\", value: scene.fog.color },\r\n            fogNear:     { type: \"f\", value: scene.fog.near },\r\n            fogFar:      { type: \"f\", value: scene.fog.far },\r\n        } ,\r\n        fog: true\r\n    })\r\n\r\n    // Mesh\r\n\r\n    const water = new THREE.Mesh(waterGeometry, waterMaterial)\r\n    water.rotation.x = - Math.PI * 0.5\r\n    water.scale.x = 8\r\n    water.scale.y = 8\r\n    return water\r\n  }\r\n\r\n  getRenderer(sizes){\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true,alpha: true })\r\n    renderer.setClearColor( 0x000000, 0 );\r\n    renderer.setSize(sizes.width, sizes.height)\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    return renderer\r\n  }\r\n\r\n  getEffectComposer(renderer,sizes,scene2,camera2){\r\n    const renderTarget2 = new THREE.WebGLRenderTarget(\r\n      800,\r\n      600,\r\n      {\r\n          minFilter: THREE.LinearFilter,\r\n          magFilter: THREE.LinearFilter,\r\n          format: THREE.RGBAFormat\r\n      }\r\n    )\r\n    const effectComposer = new EffectComposer(renderer,renderTarget2)\r\n    effectComposer.setSize(sizes.width, sizes.height)\r\n    effectComposer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\r\n    const renderPass = new RenderPass(scene2, camera2)\r\n    effectComposer.addPass(renderPass)\r\n    return effectComposer\r\n  }  \r\n\r\n  getRounderdCornersGeometry(){\r\n    const w = 9;\t// width\r\n    const h =  16;\t// height\r\n    const r = 0.5;\t// radius corner\r\n    const s = 18;\t// smoothness\r\n\r\n    // helper const's\r\n    const wi = w / 2 - r;\r\n    const hi = h / 2 - r;\r\n    const w2 = w / 2;\r\n    const h2 = h / 2;\r\n    const ul = r / w;\r\n    const ur = ( w - r ) / w;\r\n    const vl = r / h;\r\n    const vh = ( h - r ) / h;\r\n\r\n    let positions = [\r\n\r\n      -wi, -h2, 0,  wi, -h2, 0,  wi, h2, 0,\r\n      -wi, -h2, 0,  wi,  h2, 0, -wi, h2, 0,\t\r\n      -w2, -hi, 0, -wi, -hi, 0, -wi, hi, 0,\r\n      -w2, -hi, 0, -wi,  hi, 0, -w2, hi, 0,\t\r\n      wi, -hi, 0,  w2, -hi, 0,  w2, hi, 0,\r\n      wi, -hi, 0,  w2,  hi, 0,  wi, hi, 0\r\n      \r\n    ];\r\n\r\n    let uvs = [\r\n      \r\n      ul,  0, ur,  0, ur,  1,\r\n      ul,  0, ur,  1, ul,  1,\r\n      0, vl, ul, vl, ul, vh,\r\n      0, vl, ul, vh,  0, vh,\r\n      ur, vl,  1, vl,  1, vh,\r\n      ur, vl,  1, vh,\tur, vh \r\n      \r\n    ];\r\n\r\n    let phia = 0; \r\n    let phib, xc, yc, uc, vc;\r\n\r\n    for ( let i = 0; i < s * 4; i ++ ) {\r\n\r\n      phib = Math.PI * 2 * ( i + 1 ) / ( 4 * s );\r\n      \r\n      \r\n      xc = i < s || i >= 3 * s ? wi : - wi;\r\n      yc = i < 2 * s ? hi : -hi;\r\n\r\n      positions.push( xc, yc, 0, xc + r * Math.cos( phia ), yc + r * Math.sin( phia ), 0,  xc + r * Math.cos( phib ), yc + r * Math.sin( phib ), 0 );\r\n      \r\n      uc = xc = i < s || i >= 3 * s ? ur : ul;\r\n      vc = i < 2 * s ? vh : vl;\r\n      \r\n      uvs.push( uc, vc, uc + ul * Math.cos( phia ), vc + vl * Math.sin( phia ), uc + ul * Math.cos( phib ), vc + vl * Math.sin( phib ) );\r\n      \r\n      phia = phib;\r\n        \r\n    }\r\n    const geometry = new THREE.BufferGeometry( );\r\n    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions ), 3 ) );\r\n    geometry.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( uvs ), 2 ) );\r\n    return geometry\r\n  }\r\n\r\n  getPlaneRoundedCorners(renderTarget){\r\n    const material = new THREE.MeshBasicMaterial({\r\n        map: renderTarget.texture\r\n    })\r\n\r\n    const geometry = this.getRounderdCornersGeometry()\r\n\r\n    const mesh  = new THREE.Mesh(geometry, material)\r\n    mesh.material.side = THREE.DoubleSide\r\n    mesh.receiveShadow = false\r\n    \r\n    // mesh.rotation.x = -Math.PI / 2\r\n    return mesh\r\n  }\r\n\r\n  getPlaneRoundedCornersTransparent(){\r\n    const material = new THREE.MeshPhysicalMaterial({\r\n      transmission: 1,\r\n      thickness: 3,\r\n      roughness:0,\r\n      envMapIntensity:1.5,\r\n      envMap: hdrEquirect\r\n    });\r\n\r\n    // const geometry =  new THREE.IcosahedronGeometry(0.75, 0)\r\n    let width =10, height =16, depth =0 , radius0 =1, smoothness = 20\r\n    let shape = new THREE.Shape();\r\n    let eps = 0.00001;\r\n    let radius = radius0 - eps;\r\n    shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\r\n    shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\r\n    shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);\r\n    shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\r\n    let geometry = new THREE.ExtrudeBufferGeometry(shape, {\r\n      //  amount: depth - radius0 * 0.2,\r\n        amount:0.01,\r\n       bevelEnabled: true,\r\n       bevelSegments: smoothness * 2,\r\n       steps: 1,\r\n       bevelSize: radius,\r\n       bevelThickness: radius0,\r\n       curveSegments: smoothness\r\n    });\r\n \r\n    geometry.center();\r\n    \r\n    const mesh  = new THREE.Mesh(geometry, material)\r\n    mesh.material.side = THREE.DoubleSide\r\n    // mesh.receiveShadow = false\r\n    \r\n    // mesh.rotation.x = -Math.PI / 2\r\n    return mesh\r\n  }\r\n\r\n  componentDidMount() {\r\n    const sizes = this.getSizes()\r\n    // Canvas\r\n    // Scene 1\r\n    const renderer = this.getRenderer(sizes)\r\n    const canvas = renderer.domElement\r\n    const scene = this.getScene1()\r\n    const light = this.getLight1()\r\n    const water = this.getWater(scene,0.191)\r\n    const water2 = this.getWater(scene,0.291)\r\n    const water3 = this.getWater(scene,0.391)\r\n\r\n    const camera = this.getCamera1(sizes)\r\n    const controls = this.getControls1(camera,canvas)\r\n\r\n    scene.add(water)\r\n    scene.add(water2)\r\n    scene.add(water3)\r\n\r\n    scene.add(light)\r\n    scene.add(camera)\r\n\r\n    // Scene 2 (main scene)\r\n    const scene2 = new THREE.Scene()\r\n\r\n    const camera2 = this.getCamera2(sizes)\r\n    const effectComposer = this.getEffectComposer(renderer,sizes,scene2,camera2)\r\n    const controls2 = this.getControls2(camera2,canvas)\r\n    const renderTarget = new THREE.WebGLRenderTarget(512, 512);\r\n    const plane = this.getPlaneRoundedCorners(renderTarget)\r\n    const planeTransparent = this.getPlaneRoundedCornersTransparent()\r\n    scene2.add(light)\r\n    scene2.add(planeTransparent);\r\n\r\n\r\n    scene2.add(plane);\r\n\r\n    if(this.props.hasRandomInitialPosition){\r\n      var randomX = Math.ceil(Math.random() * 5) * (Math.round(Math.random()) ? 1 : -1)\r\n      var randomY = Math.ceil(Math.random() * 3) * (Math.round(Math.random()) ? 1 : -1)\r\n      camera2.position.set(randomX, randomY, 15)\r\n    }\r\n\r\n    // post processing\r\n    // const glitchPass = new GlitchPass()\r\n    // effectComposer.addPass(glitchPass)\r\n\r\n    this.scene = scene\r\n    this.camera = camera\r\n    this.camera2 = camera2\r\n    this.renderer = renderer\r\n    this.water = water\r\n    this.water2 = water2\r\n    this.water3 = water3\r\n    this.plane = plane\r\n    this.controls = controls\r\n    this.controls2 = controls2\r\n    this.renderTarget = renderTarget\r\n    this.effectComposer = effectComposer\r\n\r\n    // mandatory stuff\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    this.start()\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.stop()\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  start() {\r\n    if (!this.frameId) {\r\n      this.frameId = requestAnimationFrame(this.animate)\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    cancelAnimationFrame(this.frameId)\r\n  }\r\n\r\n  animate() {\r\n    const elapsedTime = clock.getElapsedTime()\r\n    this.water.material.uniforms.uTime.value =elapsedTime*2\r\n    this.water2.material.uniforms.uTime.value =elapsedTime*1.3\r\n    this.water3.material.uniforms.uTime.value =elapsedTime\r\n\r\n    this.controls.update()\r\n    this.controls2.update()\r\n    if(this.props.shouldRotateAutomatically && !this.state.shouldStopAutoRotate){\r\n      // this.camera2.rotation.y = 0.08 * Math.sin(elapsedTime*1.25 )\r\n      this.camera2.position.x = 3 * Math.sin(elapsedTime*1.35 )\r\n    }\r\n\r\n    this.renderScene()\r\n    this.frameId = window.requestAnimationFrame(this.animate)\r\n  }\r\n\r\n  renderScene() {\r\n    this.renderer.setRenderTarget( this.renderTarget );\r\n    this.renderer.render(this.scene, this.camera, this.renderTarget);\r\n    this.renderer.setRenderTarget( null );\r\n    this.renderer.setClearColor( 0x000000, 0 );\r\n\r\n    // Render\r\n    this.effectComposer.render()\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        onMouseDown={()=>this.setState({shouldStopAutoRotate:true})}\r\n        style={{ width: '100%', height: '100%' }}\r\n        ref={(mount) => { this.mount = mount }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Test7;","export default \"#define GLSLIFY 1\\nuniform float uBigWavesElevation;\\nuniform vec2 uBigWavesFrequency;\\nuniform float uTime;\\nuniform float uBigWavesSpeed;\\nvarying float vElevation;\\n\\nuniform float uSmallWavesElevation;\\nuniform float uSmallWavesFrequency;\\nuniform float uSmallWavesSpeed;\\nuniform float uSmallIterations;\\n\\nvec4 permute(vec4 x)\\n{\\n    return mod(((x*34.0)+1.0)*x, 289.0);\\n}\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec3 fade(vec3 t)\\n{\\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\n\\nfloat cnoise(vec3 P)\\n{\\n    vec3 Pi0 = floor(P); \\n    vec3 Pi1 = Pi0 + vec3(1.0); \\n    Pi0 = mod(Pi0, 289.0);\\n    Pi1 = mod(Pi1, 289.0);\\n    vec3 Pf0 = fract(P); \\n    vec3 Pf1 = Pf0 - vec3(1.0);\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = Pi0.zzzz;\\n    vec4 iz1 = Pi1.zzzz;\\n\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n\\n    vec4 gx0 = ixy0 / 7.0;\\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\\n    gx0 = fract(gx0);\\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n    vec4 sz0 = step(gz0, vec4(0.0));\\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n    vec4 gx1 = ixy1 / 7.0;\\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\\n    gx1 = fract(gx1);\\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n    vec4 sz1 = step(gz1, vec4(0.0));\\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n\\n    float n000 = dot(g000, Pf0);\\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n    float n111 = dot(g111, Pf1);\\n\\n    vec3 fade_xyz = fade(Pf0);\\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n    return 2.2 * n_xyz;\\n}\\nvoid main()\\n{\\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\\n\\n    float elevation = sin(modelPosition.x * uBigWavesFrequency.x + uTime * uBigWavesSpeed) * sin(modelPosition.z * uBigWavesFrequency.y + uTime * uBigWavesSpeed) * uBigWavesElevation;\\n\\n    elevation -= abs(cnoise(vec3(modelPosition.xz * 3.0, uTime * 0.2)) * 0.15);\\n\\n    for(float i = 1.0; i <= uSmallIterations; i++)\\n    {\\n        elevation -= abs(cnoise(vec3(modelPosition.xz * uSmallWavesFrequency * i, uTime * uSmallWavesSpeed)) * uSmallWavesElevation / i);\\n    }\\n    modelPosition.y += elevation;\\n    vec4 viewPosition = viewMatrix * modelPosition;\\n    vec4 projectedPosition = projectionMatrix * viewPosition;\\n\\n    gl_Position = projectedPosition;\\n    vElevation = elevation;\\n\\n}\";","export default \"#define GLSLIFY 1\\nuniform vec3 uDepthColor;\\nuniform vec3 uSurfaceColor;\\nvarying float vElevation;\\nuniform float uColorOffset;\\nuniform float uColorMultiplier;\\n\\nuniform vec3 fogColor;\\n    uniform float fogNear;\\n    uniform float fogFar;\\nvoid main()\\n{\\n   float mixStrength = (vElevation + uColorOffset) * uColorMultiplier;\\n    vec3 color = mix(uDepthColor, uSurfaceColor, mixStrength);\\n\\n    gl_FragColor = vec4(color, 1.0);\\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\\n    float fogFactor = smoothstep( fogNear, fogFar, depth );\\n    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n\\n}\";","import React from \"react\";\r\nimport Container from '@material-ui/core/Container';\r\nimport Grid from '@material-ui/core/Grid';\r\n\r\nimport Header from \"../components/Header\"\r\nimport Test from \"../components/three/Test/Test\"\r\nimport Test2 from \"../components/three/Test2/Test2\"\r\nimport Test3 from \"../components/three/Test3/Test3\"\r\nimport Test4 from \"../components/three/Test4/Test4\"\r\nimport Test5 from \"../components/three/Test5/Test5\"\r\nimport Test6 from \"../components/three/Test6/Test6\"\r\nimport Test7 from \"../components/three/Test7/Test7\"\r\n\r\n\r\nclass HomePage extends React.Component {\r\n\r\n    render() {\r\n      return (\r\n        <>\r\n        <Header />\r\n        <Container  maxWidth=\"sm\">\r\n          <Grid container>\r\n          <Grid item md={4} xs={10}>\r\n                    <div style={{height:\"360px\",width:\"100%\"}}>\r\n                        <Test7  shouldRotateAutomatically={true} hasRandomInitialPosition={true}/>\r\n                    </div>\r\n                </Grid><Grid item md={4} xs={10}>\r\n                    <div style={{height:\"360px\",width:\"100%\"}}>\r\n                        <Test7  shouldRotateAutomatically={true} hasRandomInitialPosition={true}/>\r\n                    </div>\r\n                </Grid>\r\n                <Grid item md={4} xs={10}>\r\n                    <div style={{height:\"360px\",width:\"100%\"}}>\r\n                        <Test7  shouldRotateAutomatically={true} hasRandomInitialPosition={true}/>\r\n                    </div>\r\n                </Grid>\r\n           </Grid>\r\n          {/* <Grid container spacing={2}>\r\n                <Grid item md={4} xs={12}>\r\n                    <h1 >\r\n                     Test 6\r\n                    </h1>\r\n                </Grid>\r\n                <Grid item md={8} xs={12}>\r\n                    <div style={{height:\"350px\",width:\"100%\"}}>\r\n                        <Test6 />\r\n                    </div>\r\n                </Grid>\r\n           </Grid>\r\n          <Grid container spacing={2}>\r\n                <Grid item md={4} xs={12}>\r\n                    <h1 >\r\n                     Test 5\r\n                    </h1>\r\n                </Grid>\r\n                <Grid item md={8} xs={12}>\r\n                    <div style={{height:\"350px\",width:\"100%\"}}>\r\n                        <Test5 />\r\n                    </div>\r\n                </Grid>\r\n           </Grid>\r\n           <Grid container spacing={2}>\r\n                <Grid item md={4} xs={12}>\r\n                    <h1 >\r\n                     Test 4\r\n                    </h1>\r\n                </Grid>\r\n                <Grid item md={8} xs={12}>\r\n                    <div style={{height:\"350px\",width:\"100%\"}}>\r\n                        <Test4 />\r\n                    </div>\r\n                </Grid>\r\n            </Grid>\r\n            <Grid container spacing={2}>\r\n                <Grid item md={4} xs={12}>\r\n                    <h1 >\r\n                     Test 3\r\n                    </h1>\r\n                </Grid>\r\n                <Grid item md={8} xs={12}>\r\n                    <div style={{height:\"350px\",width:\"100%\"}}>\r\n                        <Test3 />\r\n                    </div>\r\n                </Grid>\r\n            </Grid>\r\n            <Grid container spacing={2}>\r\n                <Grid item md={4} xs={12}>\r\n                    <h1 >\r\n                     Test 2\r\n                    </h1>\r\n                </Grid>\r\n                <Grid item md={8} xs={12}>\r\n                    <div style={{height:\"350px\",width:\"100%\"}}>\r\n                        <Test2 />\r\n                    </div>\r\n                </Grid>\r\n            </Grid>\r\n            <Grid container spacing={2}>\r\n                <Grid item md={4} xs={12}>\r\n                    <h1 >\r\n                     Test 1\r\n                    </h1>\r\n                </Grid>\r\n                <Grid item md={8} xs={12}>\r\n                    <div style={{height:\"350px\",width:\"100%\"}}>\r\n                        <Test />\r\n                    </div>\r\n                </Grid>\r\n            </Grid> */}\r\n        </Container>\r\n        </>\r\n      );\r\n    }\r\n  }\r\nexport default HomePage;","import React from \"react\";\r\nimport Test from \"../components/three/Test7/Test7\"\r\n\r\n\r\nclass HomePage extends React.Component {\r\n\r\n    render() {\r\n      return (\r\n        <div style={{height:\"100vh\"}}>\r\n          <Test  />\r\n        </div>\r\n      );\r\n    }\r\n  }\r\nexport default HomePage;","import React from \"react\";\r\nimport {Route, Routes  ,HashRouter} from \"react-router-dom\";\r\n\r\nimport HomePage  from './pages/HomePage';\r\nimport NFTPage  from './pages/NFTPage';\r\n\r\nclass RouterManager extends React.Component {\r\n  render() {\r\n    return (\r\n      <HashRouter>\r\n        <Routes >\r\n          <Route exact path=\"/\" element={ <HomePage/>} />\r\n          <Route exact path=\"/home\"  element={ <HomePage/>} />\r\n          <Route  path=\"/token/:id\"  element={ <NFTPage/>} />\r\n          <Route\r\n            render={function() {\r\n              return <h1>Not Found</h1>;\r\n            }}\r\n          />\r\n      </Routes>\r\n    </HashRouter>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RouterManager;\r\n","import React from \"../node_modules/react\";\r\nimport \"./App.css\";\r\nimport \"./index.css\";\r\nimport RouterManager from \"./RouterManager\";\r\n\r\nclass App extends React.Component {\r\n\r\n  render() {\r\n    return (\r\n      <RouterManager />\r\n    );\r\n  }\r\n}\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}